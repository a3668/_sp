### 運作說明

a 是暫存器

- 最一開始 e 代表 機器碼指標，指向當前的機器碼存放位置
  再來 ENT 告訴虛擬機「這裡是一個新函數的開始」。

- e 代表機器碼指標，指向當前的機器碼存放位置
- 堆疊結構：
  - bp+0：舊 bp
  - bp+1：返回地址
  - bp+2：第一個參數 n

### 216 217

```c
*e++ = LLA; // 載入區域變數的地址
*e++ = 2;   // LLA 2 代表「載入 bp + 2 的地址」，也就是 n 的位置。
```

- LLA 寫入 e 的當前位置，e 指向下一個
- 將 2 給當前 e 的位置，再將 e 指向下一個
  LLA 2 的作用是計算出參數 n 在堆疊上的地址 (bp + 2)，並把這個地址存到了 a 暫存器裡

### 219

```c
*e++ = LI;  // 載入整數
```

- LI 寫入 e 當前位置，指向下一個
- 經過 LI 指令後，暫存器 a 中存放的就是變數 n 的實際數值了

### 220

```c
*e++ = PSH; // 推入堆疊(準備比較)
```

- PSH 指令執行時，它會把 a 中存放的 n 的值推入到虛擬機的堆疊裡

### 222

```c
*e++ = IMM; // 將 0 載入 a
*e++ = 0;   // 載入 `0`，準備與 `n` 比較
```

- 將 a 設為 0,為了與 n 作比較
- 對應 if(n == 0) 判斷

### 225

```c
*e++ = EQ;  // 比較：a = *sp++ == a
```

- 將 EQ 寫入 e 的位置
- EQ 邏輯是 a = \*sp++ == a;
- \*sp++ == a 意思是從堆疊彈出一個值，將這個值與暫存器 a 中的值作比較
- 如果相等結果就是 1，不相等結果就是 0，這結果會存入 a 這個暫存器

### 227 228 229

```c
*e++ = BZ;  // 跳轉指令：如果 a 等於 0 則跳轉
loc = e;    // 記錄 BZ 指令存放的位置
*e++ = 0;   // 暫時佔位
```

- 將 BZ 這個跳轉指令寫入 e 的位置，指向下一個
- BZ 這個指令會知道如果 a 等於 0 會跳轉到哪個位置
- 備註：a 等於 0 表示 n 和 a 不相等所以不會是 return 1 而是進入遞迴
  簡單解釋(如果某個條件為零，就跳到另一頁去)（這就是 BZ 指令）
  而另一頁就是(return 2 \* power2(n - 1);)此時這代碼還沒寫

我們將 e 當前指向的地址（也就是 BZ 指令的跳轉地址參數應該存放的位置）賦值給 loc 變數
簡單解釋 loc = e; 就是 記住未來要填寫的「頁碼空位」在哪裡

在*e++ = 0;因為還不知道 BZ 的該跳轉位置(return 2 * power2(n - 1);)這代碼還沒產生，所以先用 0 這個暫時的值來佔住這個位置

### 236 237 238

```c
*e++ = IMM;
*e++ = 1;
*e++ = LEV; // 離開副程式
```

- 執行 IMM 1 會將 1 載入 a 這個暫存器，執行 LEV 指令，完成函數返回的步驟

### 241 行

```c
 *loc = (int)e;
```

在先前 loc = e; 記住了 BZ 指令後面那個存放跳轉地址參數的位置。
而現在 e 是指向(return 2 \_ power2(n - 1);)的起始位置
(int)e：將 e 這個指標強制轉型為 int long long 數值。這個數值就是當前這段程式碼的起始地址
再來將(int)e 的值寫入到 BZ 指令後面那個參數的位置
它將之前 BZ 指令後面的那個假的跳轉地址 (0) 替換為(return 2 \* power2(n - 1);)這段程式碼的真實起始地址

### 242 243 244 245 行

```c
*e++ = LLA;
*e++ = 2;  // 讀取n的地址
*e++ = LI; // 取得n的值//LI 會從 a 指向的地址讀取值，這樣 a 就會存放 n 的值。
*e++ = PSH;
```

LLA 2 就是參數 n 在堆疊上的地址(bp+2)，並將地址存入 a
備註：當執行到 LI 指令時，a 暫存器裡存的是 n 在記憶體中的位置
(int _)a 意思就是告訴虛擬機把 a 暫存器裡面的內容（假設那個地址 0x12345678）當作一個指向整數的指標來處理
_(int \*)a 就是前往這個指標(剛剛 a 中的地址 0x12345678)所指向的記憶體位置，讀取那個位置存放的值，在地址 0x12345678 存放的，正是參數 n 的數值。
PSH 將 a 中的值推入堆疊

### 247 248 249 行

```c
*e++ = IMM;
*e++ = 1;   // 載入 `1`
*e++ = SUB; // 計算 `n - 1`（`a = a - pop()`）
```

IMM 1 將 1 載入 a 暫存器中
SUB 邏輯是 a = \*sp++ - a;就是從堆疊彈出一個值而這個值去減 a 暫存器中的值
減完後的結果存回 a 這個暫存器裡

### 251 252 253 行

```c
*e++ = PSH; // 推入堆疊，準備當作 `power2(n - 1)` 的參數
*e++ = JSR;
*e++ = (int)power2; // 呼叫 `power2(n - 1)
```

```c
*e++ = PSH;
```

- PSH 將 a 中的值推入堆疊

```c
*e++ = IMM;
*e++ = 2;   // 載入 `2`
*e++ = MUL; // 計算 `2 * power2(n - 1)`
```

### main 函數的編譯：

```c
pc = e;              // 記錄 main 函數的起始位置
*e++ = ENT;          // 進入 main 函數
*e++ = 0;            // 分配 0 個區域變數
```

### printf 的編譯：

```c
*e++ = IMM;          // 載入格式化字串
*e++ = (int)"power2(3)=%d\n";
*e++ = PSH;          // 推入堆疊
*e++ = IMM;          // 載入參數 3
*e++ = 3;
*e++ = PSH;          // 推入堆疊
```

### power2 函數呼叫：

```c
*e++ = JSR;          // 跳轉到 power2 函數
*e++ = (int)power2;  // power2 函數的地址
*e++ = ADJ;          // 調整堆疊
*e++ = 1;            // 調整一個參數
```

### 堆疊初始化：

```c
bp = sp = (int *)((int)sp + poolsz);  // 設定堆疊指標
*--sp = EXIT;        // 設定程式結束點
*--sp = PSH;         // 準備呼叫
t = sp;
*--sp = (int)t;      // 設定參數
```

### 執行方式

```
./c4 -s test/power2.c
```

### 結果

```
1> ENT  0
2> IMM  69468056
3> PSH
4> IMM  3
5> PSH
6> JSR  1342210048
7> ENT  0
8> LLA  2
9> LI
10> PSH
11> IMM  0
12> EQ
13> BZ   1342210160
14> LLA  2
15> LI
16> PSH
17> IMM  1
18> SUB
19> PSH
20> JSR  1342210048
21> ENT  0
22> LLA  2
23> LI
24> PSH
25> IMM  0
26> EQ
27> BZ   1342210160
28> LLA  2
29> LI
30> PSH
31> IMM  1
32> SUB
33> PSH
34> JSR  1342210048
35> ENT  0
36> LLA  2
37> LI
38> PSH
39> IMM  0
40> EQ
41> BZ   1342210160
42> LLA  2
43> LI
44> PSH
45> IMM  1
46> SUB
47> PSH
48> JSR  1342210048
49> ENT  0
50> LLA  2
51> LI
52> PSH
53> IMM  0
54> EQ
55> BZ   1342210160
56> IMM  1
57> LEV
58> PSH
59> IMM  2
60> MUL
61> LEV
62> PSH
63> IMM  2
64> MUL
65> LEV
66> PSH
67> IMM  2
68> MUL
69> LEV
70> ADJ  1
71> PSH
72> PRTF
power2(3)=8
73> ADJ  2
74> LEV
75> PSH
76> EXIT
exit(12) cycle = 76
```
