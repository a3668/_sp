./c4 -s test/power2.c
a 是暫存器

最一開始 e 代表 機器碼指標，它指向當前的機器碼存放位置
再來 ENT 告訴虛擬機「這裡是一個新函數的開始」。

bp+0 是舊 bp，bp+1 是返回地址，bp+2 是第一個參數 n

### 216

LLA 寫入 e 的當前位置，e 指向下一個

### 217

將 2 給當前 e 的位置，再將 e 指向下一個
LLA 2 的作用是計算出參數 n 在堆疊上的地址 (bp + 2)，並把這個地址存到了 a 暫存器裡

### 219

LI 寫入 e 當前位置，指向下一個
經過 LI 指令後，暫存器 a 中存放的就是變數 n 的實際數值了

### 220

PSH 指令執行時，它會把 a 中存放的 n 的值推入到虛擬機的堆疊裡

### 222 將 a 設為 0,為了與 n 作比較

if(n == 0)

### 225

將 EQ 寫入 e 的位置
EQ 邏輯是 a = *sp++ == a;
*sp++ == a 意思是從堆疊彈出一個值，將這個值與暫存器 a 中的值作比較
如果相等結果就是 1，不相等結果就是 0，這結果會存入 a 這個暫存器

### 227 228 229

將 BZ 這個跳轉指令寫入 e 的位置，指向下一個
BZ 這個指令會知道如果 a 等於 0 會跳轉到哪個位置
備註：a 等於 0 表示 n 和 a 不相等所以不會是 return 1 而是進入遞迴
簡單解釋(如果某個條件為零，就跳到另一頁去)（這就是 BZ 指令）
而另一頁就是(return 2 \* power2(n - 1);)此時這代碼還沒寫

我們將 e 當前指向的地址（也就是 BZ 指令的跳轉地址參數應該存放的位置）賦值給 loc 變數
簡單解釋 loc = e; 就是 記住未來要填寫的「頁碼空位」在哪裡

在*e++ = 0;因為還不知道 BZ 的該跳轉位置(return 2 * power2(n - 1);)這代碼還沒產生，所以先用 0 這個暫時的值來佔住這個位置

### 236 237 238

執行 IMM 1 會將 1 載入 a 這個暫存器，執行 LEV 指令，完成函數返回的步驟

### 241

在先前 loc = e; 記住了 BZ 指令後面那個存放跳轉地址參數的位置。
而現在 e 是指向(return 2 \_ power2(n - 1);)的起始位置
(int)e：將 e 這個指標強制轉型為 int long long 數值。這個數值就是當前這段程式碼的起始地址
再來將(int)e 的值寫入到 BZ 指令後面那個參數的位置
它將之前 BZ 指令後面的那個假的跳轉地址 (0) 替換為(return 2 \* power2(n - 1);)這段程式碼的真實起始地址

### 242 243 244 245

LLA 2 就是參數 n 在堆疊上的地址(bp+2)，並將地址存入 a
備註：當執行到 LI 指令時，a 暫存器裡存的是 n 在記憶體中的位置
(int _)a 意思就是告訴虛擬機把 a 暫存器裡面的內容（假設那個地址 0x12345678）當作一個指向整數的指標來處理
_(int \*)a 就是前往這個指標(剛剛 a 中的地址 0x12345678)所指向的記憶體位置，讀取那個位置存放的值，在地址 0x12345678 存放的，正是參數 n 的數值。
PSH 將 a 中的值推入堆疊

### 247 248 249

IMM 1 將 1 載入 a 暫存器中
SUB 邏輯是 a = \*sp++ - a;就是從堆疊彈出一個值而這個值去減 a 暫存器中的值
減完後的結果存回 a 這個暫存器裡

### 251 252 253

PSH 將 a 中的值推入堆疊
